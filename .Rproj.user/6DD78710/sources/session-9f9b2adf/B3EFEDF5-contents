rm(list = ls())

source(file = "/Users/lukaswermuth/Documents/Dr.Wermuth/Rpackages/NCor/R/NCor.R")

library(arrangements)
library(rstatix)
library(foreach)
library(readr)
library(readxl)
library(haven)
library(doParallel)
library(DescTools)
library(compositions)
library(mvtnorm)

## Regression normal
MC <- 10
n <- 100000
rhos <- (seq(0, 1, length.out = 100))^2 * 4

gamma_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array

cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
on.exit(parallel::stopCluster(cl))

for (rho in rhos) {
  for (i in 1:MC) {
    print(c(rho, i))
    set.seed(i) 
    # Generate nominal covariate and create continuous dependent variable via regression
    X <- sample(c("A", "B", "C"), n, prob = c(1/3, 1/3, 1/3), replace = TRUE)
    C_ind <- ifelse(X == "C", 1, 0)
    B_ind <- ifelse(X == "B", 1, 0)
    Y <- rho * B_ind - rho * C_ind + rnorm(n)
    gamma <- NCor(X, Y, nominal = "r", CIs = FALSE, Test = FALSE)[[1]]
    gamma_array[i, as.character(rho)] <- gamma
  }
}

gammas_RegNorm <- colMeans(gamma_array)
save(gammas_RegNorm, file = "/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/NominalCorrelation/Results/Simulations/True_gammas/gammas_RegNorm.RData")

## Regression Cauchy
MC <- 10
n <- 100000
rhos <- (seq(0, 1, length.out = 100))^3 * 40

gamma_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array

cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
on.exit(parallel::stopCluster(cl))

for (rho in rhos) {
  for (i in 1:MC) {
    print(c(rho, i))
    set.seed(i) 
    # Generate nominal covariate and create continuous dependent variable via regression
    X <- sample(c("A", "B", "C"), n, prob = c(1/3, 1/3, 1/3), replace = TRUE)
    C_ind <- ifelse(X == "C", 1, 0)
    B_ind <- ifelse(X == "B", 1, 0)
    Y <- rho * B_ind - rho * C_ind + rt(n, df = 1)
    gamma <- NCor(X, Y, nominal = "r", CIs = FALSE, Test = FALSE)[[1]]
    gamma_array[i, as.character(rho)] <- gamma
  }
}

gammas_RegCauchy <- colMeans(gamma_array)
save(gammas_RegCauchy, file = "/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/NominalCorrelation/Results/Simulations/True_gammas/gammas_RegCauchy.RData")

## Multinomial Normal
MC <- 10
n <- 100000
categories <- c("A", "B", "C")  # Categories for the response variable
rhos <- (seq(0, 1, length.out = 100))^2 * 9

gamma_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array

cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
on.exit(parallel::stopCluster(cl))

for (rho in rhos) {
  for (i in 1:MC) {
    print(c(rho, i))
    set.seed(i) 
    beta_1 <- c(-rho, rho)  # Coefficients for the continuous covariate
    X <- rnorm(n)  # Simulated continuous covariate
    ProbA <- exp(X * beta_1[1]) / (1 + exp(X * beta_1[1]) + exp(X * beta_1[2]))
    ProbB <- exp(X * beta_1[2]) / (1 + exp(X * beta_1[1]) + exp(X * beta_1[2]))
    ProbC <- 1 / (1 + exp(X * beta_1[1]) + exp(X * beta_1[2]))
    # Simulate the response variable based on the calculated probabilities
    Y <- rep(NA, n)
    for (j in 1:n) {
      Y[j] <- sample(categories, size = 1, replace = TRUE, prob = cbind(ProbA[j], ProbB[j], ProbC[j]))
    }
    gamma <- NCor(Y, X, nominal = "r", CIs = FALSE, Test = FALSE)[[1]]
    gamma_array[i, as.character(rho)] <- gamma
  }
}

gammas_MultNorm <- colMeans(gamma_array)
save(gammas_MultNorm, file = "/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/NominalCorrelation/Results/Simulations/True_gammas/gammas_MultNorm.RData")

## Multinomial Cauchy
MC <- 10
n <- 100000
categories <- c("A", "B", "C")  # Categories for the response variable
rhos <- (seq(0, 1, length.out = 100))^2 * 9

gamma_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array

cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
on.exit(parallel::stopCluster(cl))

for (rho in rhos) {
  for (i in 1:MC) {
    print(c(rho, i))
    set.seed(i) 
    beta_1 <- c(-rho, rho)  # Coefficients for the continuous covariate
    X <- rt(n, df = 1)  # Simulated continuous covariate
    ProbA <- exp(X * beta_1[1]) / (1 + exp(X * beta_1[1]) + exp(X * beta_1[2]))
    ProbB <- exp(X * beta_1[2]) / (1 + exp(X * beta_1[1]) + exp(X * beta_1[2]))
    ProbC <- 1 / (1 + exp(X * beta_1[1]) + exp(X * beta_1[2]))
    ProbA[is.nan(ProbA)] <- rep(1, sum(is.nan(ProbA)))
    ProbB[is.nan(ProbB)] <- rep(1, sum(is.nan(ProbB)))
    ProbC[is.nan(ProbC)] <- rep(1, sum(is.nan(ProbC)))
    # Simulate the response variable based on the calculated probabilities
    Y <- rep(NA, n)
    for (j in 1:n) {
      Y[j] <- sample(categories, size = 1, replace = TRUE, prob = cbind(ProbA[j], ProbB[j], ProbC[j]))
    }
    gamma <- NCor(Y, X, nominal = "r", CIs = FALSE, Test = FALSE)[[1]]
    gamma_array[i, as.character(rho)] <- gamma
  }
}

gammas_MultCauchy <- colMeans(gamma_array)
save(gammas_MultCauchy, file = "/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/NominalCorrelation/Results/Simulations/True_gammas/gammas_MultCauchy.RData")

## 3 x 3 skewed uniform
MC <- 10
n <- 100000
categories <- c("A", "B", "C")  # Categories for the response variable
rhos <- (seq(0, 1, length.out = 100))^2 * 0.04

gamma_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array

cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
on.exit(parallel::stopCluster(cl))

for (rho in rhos) {
  probabilities <- matrix(c(76/300 + 2*rho, 76/300 + 2*rho, 76/300 - 4*rho, 4/100 - rho, 4/100 - rho, 4/100 + 2*rho, 4/100 - rho, 4/100 - rho, 4/100 + 2*rho), nrow = 3)
  prob_vector <- as.vector(probabilities)
  for (i in 1:MC) {
    print(c(rho, i))
    set.seed(i) 
    sampled_indices <- sample(1:9, size = n, replace = TRUE, prob = prob_vector)
    contingency_table <- table(factor(sampled_indices, levels = 1:9))
    contingency_matrix <- matrix(contingency_table, nrow = 3)
    gamma <- NCor(contingency_matrix, nominal = "rc", CIs = FALSE, Test = FALSE)[[1]]
    gamma_array[i, as.character(rho)] <- gamma
  }
}

gammas_3x3SU <- colMeans(gamma_array)
save(gammas_3x3SU, file = "/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/NominalCorrelation/Results/Simulations/True_gammas/gammas_3x3SU.RData")


## 3 x 3 uniform uniform
MC <- 10
n <- 100000
categories <- c("A", "B", "C")  # Categories for the response variable
rhos <- (seq(0, 1, length.out = 100))^2 / 36

gamma_array <- array(data = NA, dim = c(MC, length(rhos)), dimnames = list(1:MC, rhos)) # Initialize results array

cl <- makeCluster(detectCores() - 1, type = "PSOCK")
registerDoParallel(cl)
on.exit(parallel::stopCluster(cl))

for (rho in rhos) {
  probabilities <- matrix(c(1/9 + 2*rho, 1/9 + 2*rho, 1/9 - 4*rho, 1/9 - rho, 1/9 - rho, 1/9 + 2*rho, 1/9 - rho, 1/9 - rho, 1/9 + 2*rho), nrow = 3)
  prob_vector <- as.vector(probabilities)
  for (i in 1:MC) {
    print(c(rho, i))
    set.seed(i) 
    sampled_indices <- sample(1:9, size = n, replace = TRUE, prob = prob_vector)
    contingency_table <- table(factor(sampled_indices, levels = 1:9))
    contingency_matrix <- matrix(contingency_table, nrow = 3)
    gamma <- NCor(contingency_matrix, nominal = "rc", CIs = FALSE, Test = FALSE)[[1]]
    gamma_array[i, as.character(rho)] <- gamma
  }
}

gammas_3x3UU <- colMeans(gamma_array)
save(gammas_3x3UU, file = "/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/NominalCorrelation/Results/Simulations/True_gammas/gammas_3x3UU.RData")

