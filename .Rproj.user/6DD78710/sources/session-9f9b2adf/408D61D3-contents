library(ipfr)
library(DescTools)
library(foreach)
library(doParallel)
library(tidyr)
library(dplyr)
library(ggplot2)

# Function to fill in NAs based on marginals and some entries
fill_nas <- function(mat, row_totals, col_totals) {
  # Loop until all NAs are filled
  repeat {
    filled_any <- FALSE
    # Loop through rows and columns to find NAs
    for (i in 1:nrow(mat)) {
      for (j in 1:ncol(mat)) {
        if (is.na(mat[i, j])) {
          # Calculate row and column sums ignoring NAs
          current_row_sum <- sum(mat[i,], na.rm = TRUE)
          current_col_sum <- sum(mat[,j], na.rm = TRUE)
          
          # Calculate how much more is needed for row and column totals
          needed_row_value <- row_totals[i] - current_row_sum
          needed_col_value <- col_totals[j] - current_col_sum
          
          # Fill the NA with the minimum needed value
          if (needed_row_value >= 0 && needed_col_value >= 0) {
            mat[i, j] <- min(needed_row_value, needed_col_value)
            filled_any <- TRUE
          }
        }
      }
    }
    # Break the loop if no more NAs can be filled
    if (!filled_any) break
  }
  return(mat)
}

max_CramerV <- function(row_targets, column_targets, iter = 1000, max_iter = 1000, rel_gap = 0.01){
  cl <- makeCluster(detectCores() - 1, type = "PSOCK")
  registerDoParallel(cl)
  num_rows <- length(row_targets)
  num_cols <- length(column_targets)
  if (num_rows!=num_cols){stop("Please insert a quadratic matrix!")}
  mtx_prelim <- matrix(NA, nrow = num_rows, ncol = num_cols)
  row_pos <- rep(NA, num_rows)
  col_pos <- rep(NA, num_cols)
  for (i in 1:num_rows) { # Store the position of the maximal row_targets (column_targets) value, the second maximal etc.
    row_pos[i] <- order(row_targets, decreasing = TRUE)[i]
    col_pos[i] <- order(column_targets, decreasing = TRUE)[i]
    mtx_prelim[row_pos[i], col_pos[i]] <- min(row_targets[row_pos[i]], column_targets[col_pos[i]]) # fill in mtx_prelim according to heuristic
  }
  completed_matrix <- fill_nas(mtx_prelim, row_targets, column_targets)
  CramerVs <- foreach(i = 1:iter, .combine = rbind) %dopar% {
    set.seed(i)
    # joint_probs <- runif(num_rows * num_cols)
    joint_probs <- completed_matrix * matrix(rnorm(9, mean = 1, sd = 10), nrow = 3, ncol = 3)
    joint_probs <- joint_probs / sum(joint_probs)
    mtx <- matrix(data = joint_probs, nrow = num_rows, ncol = num_cols)
    final_mtx <- ipfr::ipu_matrix(mtx, row_targets, column_targets, relative_gap = rel_gap, max_iterations = max_iter)
    DescTools::CramerV(final_mtx)
  }
  return(max(CramerVs))
  stopCluster(cl)
}

Start_time <- Sys.time()
max_CramerV(c(0.98, 0.01, 0.01), c(1/3, 1/3, 1/3), iter = 100)
End_time <- Sys.time()
End_time - Start_time
# Version without educated guess: 0.2915564 with iter = 1, 0.429218 with iter = 10, 0.507814 with iter = 100, 0.6071035 with iter = 1000, 0.7043274 with iter = 10000

####### Find upper bound for Cramer's V
xlim <- c(0.01, 0.99)
ylim <- c(0.01, 0.99)
grid <- 100
iter <- 1000
max_iter <- 1000
PA <- seq(xlim[1], xlim[2], length.out = grid)
PB <- seq(ylim[1], ylim[2], length.out = grid)
data <- expand_grid(x = PA, y = PB)
z <- rep(NA,grid^2)
for (i in 1:grid){
  for (j in 1:grid){
    Start_time <- Sys.time()
    z[(i-1)*grid+j] <- max_CramerV(c(0.5*(1-PA[i]), 0.5*(1-PA[i]), PA[i]), c(0.5*(1-PB[j]), 0.5*(1-PB[j]), PB[j]), iter = iter, max_iter = max_iter)
    End_time <- Sys.time()
    print(End_time - Start_time)
  }}
data <- mutate(data, z)
save(data, file = "/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/Nominal Correlation/Results/UpperBounds/max_CramerV.RData")

# Create Heatmap for Cramer's V
load("/Users/lukaswermuth/Library/CloudStorage/Dropbox/Pohle Wermuth/Nominal Correlation/Results/UpperBounds/CramerV.RData")
bins <- 20
xlab <- "PA"
ylab <- "PB"
labels <- rep("",bins+1)
addlabels <- seq(from=0,to=1,length.out=6)
addlabelsat <- seq(from=1, to=bins+1,length.out=6)
labels[addlabelsat] <- addlabels
g <- ggplot(data, aes(x = x, y = y, fill = z)) +
  geom_tile()+
  scale_fill_stepsn(n.breaks = bins, colors = hcl.colors(9, "Blues", rev = TRUE), limits = c(0, 1), labels = labels)+
  guides(fill = guide_colourbar(title = NULL, ticks = FALSE, barheight = 10))+
  xlab(xlab) +
  ylab(ylab) +
  theme_minimal()



